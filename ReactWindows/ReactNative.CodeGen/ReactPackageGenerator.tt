//
// This file is generated by ReactPackageGenerator.tt
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var packageFullName = _metadata.Value<string>("name");
var index = packageFullName.LastIndexOf(".");
var packageNamespace = packageFullName.Substring(0, index);
var packageName = packageFullName.Substring(index + 1);
#>
using ReactNative.Bridge;
using ReactNative.Modules.Core;
using ReactNative.UIManager;
using System.Collections.Generic;

namespace <#=packageNamespace#>
{
    class Generated<#=packageName#> : IReactPackage
    {
        private readonly IReactPackage _reactPackage;

        public Generated<#=packageName#>(IReactPackage reactPackage)
        {
            _reactPackage = reactPackage;
        }

        public IReadOnlyList<INativeModule> CreateNativeModules(ReactContext reactContext)
        {
            var nativeModules = _reactPackage.CreateNativeModules(reactContext);
            return new List<INativeModule>
            {
<#
var modules = _metadata["modules"];
var moduleCount = modules.Count();
for (var i = 0; i < moduleCount; ++i)
{
    var module = modules[i];
    var moduleFullName = module.Value<string>("name");
    var moduleName = moduleFullName.Substring(moduleFullName.LastIndexOf(".") + 1);
#>
                new <#=moduleName#>Wrapper((<#=moduleFullName#>)nativeModules[<#=i#>]),
<#
}
#>
            };
        }

        public IReadOnlyList<IViewManager> CreateViewManagers(ReactContext reactContext)
        {
            return _reactPackage.CreateViewManagers(reactContext);
        }
<#
for (var i = 0; i < moduleCount; ++i)
{
    var module = modules[i];
    var moduleFullName = module.Value<string>("name");
    var moduleName = moduleFullName.Substring(moduleFullName.LastIndexOf(".") + 1);
#>
        class <#=moduleName#>Wrapper : NativeModuleWrapperBase<<#=moduleFullName#>>
        {
            public <#=moduleName#>Wrapper(<#=moduleFullName#> nativeModule)
                : base(nativeModule)
            {
            }

            public override IReadOnlyDictionary<string, INativeMethod> Methods
            {
                get
                {
                    return new Dictionary<string, INativeMethod>
                    {
<#
    foreach (var method in module["methods"])
    {
        var methodName = method.Value<string>("name");
        var methodType = method.Value<string>("type");
#>
                        {
                            nameof(<#=moduleFullName#>.<#=methodName#>),
                            new NativeMethod("<#=methodType#>", (instance, args) =>
                                Module.<#=methodName#>(
<#
        var parameters = method["parameters"];
        var parameterCount = parameters.Count();
        for (var j = 0; j < parameterCount; ++j)
        {
            var comma = j < (parameterCount - 1) ? "," : "";
            var parameter = parameters[j];
            var kind = parameter.Value<string>("kind");
            if (kind == "json")
            {
                var type = parameter.Value<string>("type");
#>
                                    (<#=type#>)args[<#=j#>]<#=comma#>
<#
            }
            else if (kind == "callback")
            {
#>
                                    new Callback(args[<#=j#>].ToObject<int>(), instance)<#=comma#>
<#
            }
            else if (kind == "promise")
            {
#>
                                    new Promise(
                                        new Callback(args[<#=j#>].ToObject<int>(), instance),
                                        new Callback(args[<#=j + 1#>].ToObject<int>(), instance)
                                    )<#=comma#>
<#
            }
            else if (kind == "nullable")
            {
                var type = parameter.Value<string>("type");
#>
                                    args[<#=j#>].ToObject<<#=type#>?>()<#=comma#>
<#
            }
            else
            {
                var type = parameter.Value<string>("type");
#>
                                    args[<#=j#>].ToObject<<#=type#>>()<#=comma#>
<#
            }
        }
#>
                                )
                            )
                        },
<#
    }
#>
                    };
                }
            }
        }
<#
}
#>
    }
}
